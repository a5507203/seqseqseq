<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Learn & Explore 10 – Quiz-Gated Metroidvania</title>
  <style>
    /* Basic page and canvas styles */
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    canvas { display: block; background: #222; }
    /* Quiz overlay styles */
    #quizOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      visibility: hidden;
    }
    .quizContent {
      background: #333;
      padding: 20px;
      border-radius: 8px;
      width: 90%; max-width: 400px;
    }
    .quizContent h2 {
      margin-top: 0;
      font-size: 1.2em;
    }
    .options button {
      display: block;
      margin: 8px 0;
      width: 100%;
      padding: 8px;
      background: #555;
      border: none;
      color: #fff;
      cursor: pointer;
      border-radius: 4px;
    }
    .options button:hover { background: #666; }
    #feedback { margin-top: 10px; min-height: 1.2em; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="quizOverlay">
    <div class="quizContent">
      <h2 id="quizTitle">Quiz Time!</h2>
      <div id="questionText"></div>
      <div class="options" id="optionsContainer"></div>
      <div id="feedback"></div>
    </div>
  </div>
  <script>
    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 800;
    canvas.height = 600;

    // Input tracking
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key] = true; });
    window.addEventListener('keyup', e => { keys[e.key] = false; });

    // Game state containers
    let platforms = [];
    let gates = [];
    let orbs = [];
    let activeQuiz = null;

    // Player class
    class Player {
      constructor() {
        this.x = 50;
        this.y = 500;
        this.w = 40;
        this.h = 60;
        this.velX = 0;
        this.velY = 0;
        this.speed = 3;
        this.gravity = 0.6;
        this.jumpStrength = 12;
        this.canDoubleJump = false;
        this.abilities = { fire: false, ice: false, doubleJump: false };
      }
      update() {
        // Horizontal movement
        if (keys['ArrowLeft'] || keys['a']) this.velX = -this.speed;
        else if (keys['ArrowRight'] || keys['d']) this.velX = this.speed;
        else this.velX = 0;
        // Jump
        if ((keys['ArrowUp'] || keys['w'] || keys[' ']) && this.onGround) {
          this.velY = -this.jumpStrength;
          this.onGround = false;
        } else if ((keys['ArrowUp'] || keys['w'] || keys[' ']) && !this.onGround && this.abilities.doubleJump && !this.canDoubleJump) {
          this.velY = -this.jumpStrength;
          this.canDoubleJump = true;
        }
        // Apply gravity
        this.velY += this.gravity;
        // Position update
        this.x += this.velX;
        this.y += this.velY;
        // Reset double jump when landing
        if (this.onGround) this.canDoubleJump = false;
        // TODO: Collision with platforms, gates, orbs
      }
      draw() {
        ctx.fillStyle = '#0f0';
        ctx.fillRect(this.x, this.y, this.w, this.h);
      }
    }

    // Instantiate player
    const player = new Player();

    // Main game loop
    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // TODO: draw platforms, gates, orbs
      player.update();
      player.draw();
      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

    // Placeholder for quiz functions (to implement)
    function openQuiz(orb) {
      // TODO: pause game, show quizOverlay, load orb-specific questions
    }
    function closeQuiz() {
      document.getElementById('quizOverlay').style.visibility = 'hidden';
      activeQuiz = null;
      // resume game
    }
  </script>

<script>
  // --- Level Data and Initialization ---
  // Simple platform definitions: x, y, width, height
  platforms = [
    { x: 0, y: 580, w: 800, h: 20 },         // ground
    { x: 150, y: 450, w: 200, h: 20 },
    { x: 400, y: 350, w: 150, h: 20 },
    { x: 600, y: 250, w: 150, h: 20 }
  ];
  // Gates: x, y, w, h, type, opened?
  gates = [
    { x: 370, y: 320, w: 60, h: 30, type: 'fire', opened: false },
    { x: 580, y: 220, w: 60, h: 30, type: 'ice', opened: false },
    { x: 200, y: 420, w: 60, h: 30, type: 'doubleJump', opened: false }
  ];
  // Orbs: x, y, r, type
  orbs = [
    { x: 180, y: 410, r: 10, type: 'doubleJump' },
    { x: 430, y: 320, r: 10, type: 'fire' },
    { x: 630, y: 220, r: 10, type: 'ice' }
  ];

  // Question bank per ability type
  const questionBank = {
    fire: [
      { q: 'What does H2O represent?', opts: ['A: Water','B: Oxygen','C: Hydrogen','D: Salt'], ans: 'A' },
      { q: 'What planet is known as the Red Planet?', opts: ['A: Venus','B: Mars','C: Jupiter','D: Saturn'], ans: 'B' },
      { q: 'Which element is used in fire extinguishers?', opts: ['A: Argon','B: Helium','C: Carbon Dioxide','D: Neon'], ans: 'C' }
    ],
    ice: [
      { q: 'Who discovered America in 1492?', opts: ['A: Columbus','B: Magellan','C: Cook','D: Cabot'], ans: 'A' },
      { q: 'In which year did WW2 end?', opts: ['A: 1940','B: 1945','C: 1950','D: 1939'], ans: 'B' },
      { q: 'Which empire was ruled by Julius Caesar?', opts: ['A: Greek','B: Roman','C: Ottoman','D: British'], ans: 'B' }
    ],
    doubleJump: [
      { q: 'What is 7 × 8?', opts: ['A: 54','B: 56','C: 58','D: 60'], ans: 'B' },
      { q: 'What is the square root of 49?', opts: ['A: 6','B: 7','C: 8','D: 9'], ans: 'B' },
      { q: 'What is 12 ÷ 3?', opts: ['A: 2','B: 3','C: 4','D: 6'], ans: 'C' }
    ]
  };

  // Collision helpers
  function rectIntersect(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x &&
           a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function circleRectIntersect(c, r) {
    // c: {x,y,r}, r: {x,y,w,h}
    let distX = Math.abs(c.x - (r.x + r.w/2));
    let distY = Math.abs(c.y - (r.y + r.h/2));
    if (distX > (r.w/2 + c.r) || distY > (r.h/2 + c.r)) return false;
    if (distX <= r.w/2 || distY <= r.h/2) return true;
    let dx = distX - r.w/2;
    let dy = distY - r.h/2;
    return (dx*dx + dy*dy <= c.r*c.r);
  }

  // Extend Player.update for collisions
  Player.prototype.update = (function(orig) {
    return function() {
      if (activeQuiz) return;  // pause movement during quiz
      orig.call(this);
      this.onGround = false;
      // Platform collision
      for (let p of platforms) {
        if (rectIntersect(this, p) && this.velY >= 0) {
          this.y = p.y - this.h;
          this.velY = 0;
          this.onGround = true;
        }
      }
      // Gate collision / interaction
      for (let g of gates) {
        if (!g.opened && rectIntersect(this, g)) {
          if (this.abilities[g.type]) {
            g.opened = true; // auto-break gate
          } else {
            // block movement
            if (this.velX > 0) this.x = g.x - this.w;
            else if (this.velX < 0) this.x = g.x + g.w;
          }
        }
      }
      // Orb collection
      for (let orb of orbs) {
        if (circleRectIntersect(orb, this)) {
          openQuiz(orb);
          break;
        }
      }
    }
  })(Player.prototype.update);

  // Draw platforms, gates, orbs
  function drawWorld() {
    ctx.fillStyle = '#888';
    platforms.forEach(p => ctx.fillRect(p.x, p.y, p.w, p.h));
    gates.forEach(g => {
      ctx.fillStyle = g.opened ? 'rgba(0,0,0,0)' : (g.type === 'fire'? '#f55' : g.type==='ice'? '#5af':'#fa5');
      ctx.fillRect(g.x, g.y, g.w, g.h);
    });
    orbs.forEach(o => {
      ctx.beginPath();
      ctx.arc(o.x, o.y, o.r, 0, Math.PI*2);
      ctx.fillStyle = activeQuiz && activeQuiz.orb === o ? '#555' : '#ff0';
      ctx.fill();
    });
  }

  // Quiz state
  let activeQuiz = null;

  function openQuiz(orb) {
    if (activeQuiz) return;
    activeQuiz = {
      orb,
      questions: JSON.parse(JSON.stringify(questionBank[orb.type])),
      index: 0,
      score: 0
    };
    document.getElementById('quizOverlay').style.visibility = 'visible';
    showQuestion();
  }

  function showQuestion() {
    let qObj = activeQuiz.questions[activeQuiz.index];
    document.getElementById('quizTitle').textContent = 'Quiz: ' + activeQuiz.orb.type;
    document.getElementById('questionText').textContent = qObj.q;
    let opts = document.getElementById('optionsContainer');
    opts.innerHTML = '';
    qObj.opts.forEach(opt => {
      let btn = document.createElement('button');
      btn.textContent = opt;
      btn.onclick = () => selectAnswer(opt.charAt(0));
      opts.appendChild(btn);
    });
    document.getElementById('feedback').textContent = '';
  }

  function selectAnswer(letter) {
    let qObj = activeQuiz.questions[activeQuiz.index];
    let fb = document.getElementById('feedback');
    if (letter === qObj.ans) {
      activeQuiz.score++;
      fb.textContent = 'Correct!';
    } else {
      fb.textContent = 'Wrong. The answer was ' + qObj.ans;
    }
    // next or finish
    setTimeout(() => {
      activeQuiz.index++;
      if (activeQuiz.index < activeQuiz.questions.length) {
        showQuestion();
      } else {
        finalizeQuiz();
      }
    }, 800);
  }

  function finalizeQuiz() {
    let orb = activeQuiz.orb;
    if (activeQuiz.score === activeQuiz.questions.length) {
      player.abilities[orb.type] = true;
      orbs = orbs.filter(o => o !== orb);
    }
    closeQuiz();
  }

  function closeQuiz() {
    document.getElementById('quizOverlay').style.visibility = 'hidden';
    activeQuiz = null;
  }

  // Updated game loop
  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawWorld();
    player.update();
    player.draw();
    requestAnimationFrame(gameLoop);
  }
  requestAnimationFrame(gameLoop);
</script>  
<script>
  // HUD message state
  let hudMessage = '';
  let hudTimer = 0;
  function showHUDMessage(msg, duration = 180) {
    hudMessage = msg;
    hudTimer = duration;
  }

  // Draw on-screen UI: abilities and HUD messages
  function drawUI() {
    ctx.fillStyle = '#fff';
    ctx.font = '16px sans-serif';
    // List unlocked abilities
    let parts = [];
    if (player.abilities.fire) parts.push('Fire Blast');
    if (player.abilities.ice) parts.push('Ice Dash');
    if (player.abilities.doubleJump) parts.push('Double Jump');
    let abilitiesText = 'Abilities: ' + (parts.length ? parts.join(', ') : 'None');
    ctx.fillText(abilitiesText, 10, 20);
    // Draw any active HUD message
    if (hudTimer > 0) {
      ctx.fillStyle = '#ff0';
      ctx.fillText(hudMessage, 10, 45);
      hudTimer--;
    }
  }

  // Integrate HUD messaging into quiz finalization
  function finalizeQuiz() {
    let orb = activeQuiz.orb;
    if (activeQuiz.score === activeQuiz.questions.length) {
      player.abilities[orb.type] = true;
      orbs = orbs.filter(o => o !== orb);
      showHUDMessage('Unlocked ' + orb.type + ' ability!');
    } else {
      showHUDMessage('Quiz failed! Try again later.');
    }
    closeQuiz();
  }

  // Updated game loop to draw UI
  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawWorld();
    player.update();
    player.draw();
    drawUI();
    requestAnimationFrame(gameLoop);
  }
  requestAnimationFrame(gameLoop);
</script>
</body>
</html>
